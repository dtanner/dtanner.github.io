<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on The Witty Ginger</title>
    <link>https://dtanner.github.io/post/index.xml</link>
    <description>Recent content in Posts on The Witty Ginger</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Apr 2016 02:26:00 +0000</lastBuildDate>
    <atom:link href="https://dtanner.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>java.time for the extremely impatient</title>
      <link>https://dtanner.github.io/post/javatime-for-impatient/</link>
      <pubDate>Wed, 13 Apr 2016 02:26:00 +0000</pubDate>
      
      <guid>https://dtanner.github.io/post/javatime-for-impatient/</guid>
      <description>

&lt;p&gt;This is a super quick history and primer for those familiar with java, but unfamiliar with &lt;a href=&#34;http://www.joda.org/joda-time/&#34;&gt;Joda-Time&lt;/a&gt;.
Java’s original date and time handling had some issues that could make it cumbersome and error-prone to work with. Then came the Joda-Time library, which is a fantastic replacement for pretty much everything date and time related. It’s intuitive, clean, fully-featured, and performant.&lt;/p&gt;

&lt;p&gt;Starting with Java 8, the library was folded into the core JDK, with very few modifications to the Joda API.&lt;/p&gt;

&lt;p&gt;In short, if you’re not on Java 8 yet, you should probably be using the joda-time library. If you are on Java 8, you should use the java.time classes.&lt;/p&gt;

&lt;p&gt;There’s much more to the package than what I’ll show, and you’ll eventually want to dive deeper, but this article shows you some of the most frequently used techniques I’ve experienced on the last few projects. I’m using groovy for the code snippets, but they’re just java without the semicolons.&lt;/p&gt;

&lt;h4 id=&#34;91-83-of-the-time-you-ll-work-with-localdate-or-zoneddatetime&#34;&gt;91.83% of the time, you’ll work with LocalDate or ZonedDateTime.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;import java.time.LocalDate
import java.time.ZonedDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.time.temporal.TemporalAdjusters

// If you have a date without time information, use a LocalDate. e.g. someone&#39;s birthday
LocalDate localDate = new LocalDate(2016, 4, 12)
println localDate.toString()  // 2016-04-12

// If you need to include time in the date, use ZonedDateTime
ZonedDateTime zdt = ZonedDateTime.now() 

// when formatting a ZonedDateTime for API communication, you&#39;ll typically use the DateTimeFormatter.ISO_INSTANT format
println zdt.format(DateTimeFormatter.ISO_INSTANT)
// 2016-04-12T19:20:45.539Z

// some more examples of formatters
println zdt.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)
// 2016-04-12T14:20:45.539

println zdt.format(DateTimeFormatter.RFC_1123_DATE_TIME)
// Tue, 12 Apr 2016 14:20:45 -0500

println zdt.format(DateTimeFormatter.ISO_ZONED_DATE_TIME)
// 2016-04-12T14:20:45.539-05:00[America/Chicago]

// you can also create a custom formatter
DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&amp;quot;MMM dd yyyy GG&amp;quot;)
println zdt.format(formatter)
// Apr 12 2016 AD
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;date-manipulation-is-fluent-and-intuitive&#34;&gt;Date manipulation is fluent and intuitive.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;import java.time.LocalDate
import java.time.temporal.TemporalAdjusters

LocalDate localDate = LocalDate.now()
println localDate 
// 2016-04-12

println localDate.plusMonths(1).withDayOfMonth(1)
// 2016-05-01

println localDate.minusMonths(1).with(TemporalAdjusters.lastDayOfMonth())
// 2016-03-31
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;prefer-to-work-in-utc-if-you-can-logs-database-timestamps-consistency-helps-avoid-mistakes&#34;&gt;Prefer to work in UTC if you can - logs, database timestamps…consistency helps avoid mistakes.&lt;/h4&gt;

&lt;p&gt;In a startup class: &lt;code&gt;TimeZone.setDefault(TimeZone.getTimeZone(&amp;quot;UTC&amp;quot;))&lt;/code&gt;&lt;br /&gt;
or as a JVM flag: &lt;code&gt;-Duser.timezone=UTC&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;when-working-with-a-point-in-time-always-be-aware-of-timezone&#34;&gt;When working with a point in time, always be aware of timezone!!!!&lt;/h4&gt;

&lt;p&gt;Even when working with objects like LocalDate, you must be timezone aware if you’re using a point-in-time operation. And by point-in-time, 99.273% of the time I’m referring to the now() method.
For example, given the following scenario:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The default JVM timezone is &lt;code&gt;UTC&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;At &lt;code&gt;2016-04-12 3:10 PM&lt;/code&gt; in &lt;code&gt;America/Chicago&lt;/code&gt; (which is GMT-6), a call to println &lt;code&gt;LocalDate.now()&lt;/code&gt; will result in &lt;code&gt;2016-04-12&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But at &lt;code&gt;2016-04-12 6:10 PM&lt;/code&gt; in &lt;code&gt;America/Chicago&lt;/code&gt;, the same call will result in &lt;code&gt;2016-04-13&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you’re in Chicago, that looks like tomorrow, and might be a bug for what you’re trying to do! The code is doing precisely what it’s told though; the date in London is April 13th at the time the LocalDate is created for the UTC timezone.&lt;/p&gt;

&lt;p&gt;So to repeat, when working with specific points in time, be aware of the timezone you’re working with. For example, if you want to set a date 30 days out from now according to your business location, you could say &lt;code&gt;LocalDate.now(ZoneId.of(&#39;America/Chicago&#39;)).plusDays(30)&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;further-reading&#34;&gt;Further Reading&lt;/h4&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html&#34;&gt;java.time javadocs&lt;/a&gt; are actually really good, so read them for more detailed information. Wrapping up the whirlwind tour, here’s a quick table to help get you started with a few objects and their example uses:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Object&lt;/th&gt;
&lt;th&gt;Example Usage and Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LocalDate&lt;/td&gt;
&lt;td&gt;Birthday, Contract date where no time or timezone is needed&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZonedDateTime&lt;/td&gt;
&lt;td&gt;Most points in time, like some startDateTime, endDateTime&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;YearMonth&lt;/td&gt;
&lt;td&gt;When you only want to work with a year/month combination. Less commonly used, but handy for date comparisons if you don’t want granularity to the day. e.g. Credit Card Expiration Month&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LocalTime&lt;/td&gt;
&lt;td&gt;e.g. Chris’s hardware store opens at 8 am. This date is irrespective of timezone (i.e. you wouldn’t change the opening time when daylight savings rolls around.)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Grails Tomcat datasource configuration with Etcd</title>
      <link>https://dtanner.github.io/post/dynamic-grails-tomcat-datasource/</link>
      <pubDate>Thu, 30 Apr 2015 06:05:00 +0000</pubDate>
      
      <guid>https://dtanner.github.io/post/dynamic-grails-tomcat-datasource/</guid>
      <description>

&lt;p&gt;Ever wonder if you could modify a Grails datasource while the app is running?
Probably not, and that&amp;rsquo;s totally fine&amp;hellip;most people don&amp;rsquo;t need to. We had a couple reasons though:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;During a disaster recovery situation where a non-clustered database goes down, you want to point all the apps at a failover database.  By default this means you have to update the config and restart all the apps.  On a typical AWS instance, this means at least a minute of downtime for a bigger Grails app.  Not the end of the world, but not great.&lt;/li&gt;
&lt;li&gt;One of our databases is a catalog of product information that can be drastically changed.  We wanted to be able to clone the catalog, apply massive data changes to it (this can take a minute or so), and then point all the apps in the cluster to this new database without downtime.  And we also want to be able to revert to the old database if something goes wrong.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;first-question-how-can-you-change-a-tomcat-datasource-while-the-app-is-running&#34;&gt;First question - how can you change a Tomcat datasource while the app is running?&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package com.foo.util

import groovy.util.logging.Log4j
import org.apache.tomcat.jdbc.pool.ConnectionPool
import org.codehaus.groovy.grails.commons.GrailsApplication

@Log4j
class TomcatDatasourceUtil {

    static void ensureCurrentDatasources(GrailsApplication application, List datasourceNames) {
        log.debug &amp;quot;Ensuring datasources are current&amp;quot;
        datasourceNames.each { String datasourceName -&amp;gt;
            ConnectionPool connectionPool = application.mainContext.getBean(datasourceName).targetDataSource.targetDataSource.pool

            def dataSourceFileConfig = application.config.&amp;quot;$datasourceName&amp;quot;

            // discover the properties we want to potentially change. if changed, update and purge the pool
            List propertyNames = [&#39;url&#39;, &#39;username&#39;, &#39;password&#39;]
            if (propertyNames.any { String propertyName -&amp;gt;
                connectionPool.poolProperties.&amp;quot;${propertyName}&amp;quot; != dataSourceFileConfig.&amp;quot;${propertyName}&amp;quot;
            }) {
                connectionPool.poolProperties.url = dataSourceFileConfig.url
                connectionPool.poolProperties.username = dataSourceFileConfig.username
                connectionPool.poolProperties.password = dataSourceFileConfig.password
                connectionPool.purge()
                log.info(&amp;quot;${datasourceName} was modified and refreshed&amp;quot;)
            } else {
                log.info(&amp;quot;${datasourceName} didn&#39;t change&amp;quot;)
            }
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Grails version 2.3 and onwards uses the &lt;a href=&#34;https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html&#34;&gt;Tomcat Connection Pool&lt;/a&gt; as its datasource provider by default.  If you&amp;rsquo;re not using Grails 2.3+ yet, you&amp;rsquo;re probably using the Apache Commons DBCP, and can switch by using &lt;a href=&#34;http://grails.org/plugin/jdbc-pool&#34;&gt;this plugin&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Basically, you pass the &lt;code&gt;ensureCurrentDatasources&lt;/code&gt; method your grailsApplication and a list of datasource names you want to inspect for changes and potentially refresh.  The datasource name(s) are typically defined in your DataSource.groovy.  e.g. If you only have one datasource, it&amp;rsquo;ll be named &amp;ldquo;dataSource&amp;rdquo;.  If you&amp;rsquo;re using multiple datasources, they might be named &amp;ldquo;dataSource_auditing&amp;rdquo; or whatever you&amp;rsquo;ve specified.&lt;/p&gt;

&lt;p&gt;The method is implemented to compare the current Tomcat connection pool values for the username, password, and url against the current Grails configuration values.  If any settings have changed, it&amp;rsquo;ll update those connection pool settings and call the purge() method in the connection pool.  purge() will basically perform a graceful reset of all the connections so that they establish their next connection with the updated configuration.  I chose username, password, and url because those are the things that we might change.  There are more properties in the pool that you could possibly change, but you probably don&amp;rsquo;t want to change much else, since there is some critical state being managed by some of the properties.&lt;/p&gt;

&lt;p&gt;OK, so you know a way to dynamically update a datasource while the app is running.&lt;/p&gt;

&lt;h4 id=&#34;next-question-how-should-i-wire-in-this-dynamic-update-capability&#34;&gt;Next question: How should I wire in this dynamic update capability?&lt;/h4&gt;

&lt;p&gt;The short answer is, whatever works best for you.  Here&amp;rsquo;s the path we went down&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The initial approach:&lt;/strong&gt;&lt;br /&gt;
Our application has the following attributes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It uses an inline plugin where we keep our domain classes and services.&lt;/li&gt;
&lt;li&gt;We use &lt;a href=&#34;https://saltstack.com/&#34;&gt;Salt&lt;/a&gt; to manage our external config files&lt;/li&gt;
&lt;li&gt;It uses the &lt;a href=&#34;https://github.com/bluesliverx/grails-external-config-reload&#34;&gt;External Config Reload&lt;/a&gt; plugin to allow us to dynamically update the app config when we change the config files.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With those attributes, we initially implemented a hook into the TomcatDatasourceUtil by defining the onConfigChange event in our plugin&amp;rsquo;s Config.groovy, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def onConfigChange = { event -&amp;gt;
    TomcatDatasourceUtil.ensureCurrentDatasources(
            application, 
            [&#39;dataSource&#39;, &#39;dataSource_auditing&#39;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This worked fine, but seemed like a clunky solution.  For the catalog database update scenario, the application essentially needs to remotely communicate with salt, so that salt could remotely update all of the application&amp;rsquo;s configuration files.  We keep all our salt configurations in source control, which didn&amp;rsquo;t really fit the model of what we wanted to do.&lt;/p&gt;

&lt;h4 id=&#34;the-better-approach-or-at-least-this-has-been-working-well-for-us-so-far&#34;&gt;The better approach&amp;hellip;or at least this has been working well for us so far:&lt;/h4&gt;

&lt;p&gt;Rather than use a tool to constantly push out config file changes on the fly to our cluster of apps, we thought it would be better if we inverted the technique&amp;hellip;i.e. have all the applications get their configuration from a central location.  This is where &lt;a href=&#34;https://github.com/coreos/etcd&#34;&gt;etcd&lt;/a&gt; comes in.  The summary of etcd is that it&amp;rsquo;s &amp;ldquo;a distributed, consistent key value store for shared configuration and service discovery with a focus on being simple, secure, fast, and reliable.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;You can run just about any groovy code in your Config.groovy and Datasource.groovy.  So rather than have the application get its datasource config info from a file, we have it load the datasource URL from etcd.  e.g. Here&amp;rsquo;s a snippet from our external config file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import groovy.json.JsonSlurper

dataSource {
    // most properties are directly set
    pooled = true
    // ...
    
    // the url is retrieved from etcd...make sure the etcd resource is properly protected
    def jsonSlurper = new JsonSlurper()
    def catalogUrlConfig = jsonSlurper.parseText(new URL(&amp;quot;http://etcdlocation:2379/v2/keys/dataSource/url&amp;quot;).text)
    url = catalogUrlConfig.node.value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will take care of your app getting its initial url value from etcd.  You can put whatever else in etcd that you want&amp;hellip;for our case we only need to dynamically change the url.&lt;/p&gt;

&lt;h4 id=&#34;so-now-how-do-you-update-the-datasource-for-a-cluster-of-applications&#34;&gt;So now how do you update the datasource for a cluster of applications?&lt;/h4&gt;

&lt;p&gt;In your application&amp;rsquo;s Bootstrap.groovy init, make a call to a class like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.foo.config

import com.foog.util.TomcatDatasourceUtil
import grails.plugins.rest.client.RestBuilder
import groovy.json.JsonSlurper

/**
 * Application service to get and set values from a centralized remote configuration service.
 */
class RemoteConfigService {
    def grailsApplication

    public static final String CATALOG_DB_URL_KEY = &amp;quot;dataSource/url&amp;quot;
    protected static final int INITIAL_RETRY_TIMEOUT_SECS = 5

    /**
     * Runs a process to watch for configuration changes to the plancatalog datasource URL.
     * If the URL value changes, call the datasource utility to update the connections to point at the new database.
     */
    void watchForChanges() {
        if (!grailsApplication.config.remoteConfig.enabled) {
            log.info &amp;quot;remoteConfigBaseUrl not configured - will not watch for config changes&amp;quot;
            return
        }
        log.debug(&amp;quot;watching for changes&amp;quot;)

        Thread.startDaemon {
            int secondsToWait = INITIAL_RETRY_TIMEOUT_SECS
            while (true) {
                try {
                    String url = get(&amp;quot;${CATALOG_DB_URL_KEY}?wait=true&amp;quot;)
                    if (url) {
                        grailsApplication.config.dataSource_plancatalog.url = url
                        TomcatDatasourceUtil.ensureCurrentDatasources(grailsApplication, [&#39;dataSource_plancatalog&#39;])
                    }
                    secondsToWait = INITIAL_RETRY_TIMEOUT_SECS
                } catch (Exception e) {
                    log.warn(&amp;quot;Exception occurred while watching for config changes. Will wait ${secondsToWait} seconds and continue watching&amp;quot;, e)
                    Thread.sleep(1000 * secondsToWait)
                    // double the length of the time to wait before retrying, up to a maximum of 30 minutes
                    secondsToWait = [60 * 30, 2 * secondsToWait].min()
                }
            }
        }
    }

    /**
     * Get the configured value for the given key
     * @param key
     * @return the current value
     */
    String get(String key) {
        def jsonSlurper = new JsonSlurper()
        def json = jsonSlurper.parseText(new URL(&amp;quot;${grailsApplication.config.remoteConfig.baseUrl}/${key}&amp;quot;).text)
        return json?.node?.value
    }

    /**
     * Set the given key to the given value in the centralized configuration service
     * @param key
     * @param valueArg
     */
    void set(String key, String valueArg) {
        RestBuilder rest = new RestBuilder()
        def resp = rest.put(&amp;quot;${grailsApplication.config.remoteConfig.baseUrl}/${key}&amp;quot;) {
            value = valueArg
        }
        if (resp.status != 200) {
            throw new Exception(&amp;quot;Error setting configuration value for key=${key}. Response=${resp.body}&amp;quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a very basic implementation of an etcd client that can watch for changes, update the grails configuration upon change, and also allow the app to update an etcd value.  There are more robust etcd clients available, but we didn&amp;rsquo;t need (at least not yet) the added dependencies and complexity.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s pretty fun to watch once you get it all working.  Essentially this is the flow:&lt;br /&gt;
1. A cluster of grails applications start up, configure their datasource URL using the etcd config, and watch for changes.&lt;br /&gt;
2. Some time later, one of the applications clones the database, makes changes to it, and then sets the new URL value in etcd.&lt;br /&gt;
3. All the applications are then notified of the updated etcd value and dynamically update their datasource to point at the new URL.&lt;br /&gt;
4. &amp;ldquo;dataSource was modified and refreshed&amp;rdquo;!&lt;/p&gt;

&lt;p&gt;Does this actually work?
Yup - extremely well.  I actually expected the initial implementation to be a little brittle (e.g. maybe needing a more robust etcd client), but it didn&amp;rsquo;t need any changes in the 6 months I watched it in production.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>